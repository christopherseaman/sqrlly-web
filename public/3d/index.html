<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Variable Plot</title>
    <style>
        body {
            margin: 0;
            padding: 10px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            overflow-x: hidden;
            touch-action: none;
        }

```
    @media (max-width: 768px) {
        body { padding: 5px; }
    }
    
    h1 {
        text-align: center;
        margin-bottom: 15px;
        color: #ffffff;
        text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        font-size: clamp(1.2rem, 4vw, 2rem);
    }
    
    #container {
        width: 100%;
        height: 70vh;
        min-height: 400px;
        background: rgba(0,0,0,0.3);
        border-radius: 15px;
        position: relative;
        box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255,255,255,0.1);
        touch-action: none;
    }
    
    #info {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 100;
        background: rgba(0,0,0,0.8);
        padding: 10px;
        border-radius: 8px;
        max-width: 250px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255,255,255,0.1);
        font-size: 12px;
    }
    
    @media (max-width: 768px) {
        #info {
            font-size: 11px;
            padding: 8px;
            max-width: 200px;
        }
    }
    
    .legend {
        margin-top: 15px;
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        justify-content: center;
        background: rgba(255,255,255,0.1);
        padding: 15px;
        border-radius: 15px;
        backdrop-filter: blur(10px);
    }
    
    @media (max-width: 768px) {
        .legend {
            gap: 10px;
            padding: 10px;
        }
    }
    
    .legend-item {
        display: flex;
        align-items: center;
        gap: 6px;
        font-weight: 500;
        font-size: clamp(11px, 2.5vw, 14px);
    }
    
    .color-box {
        width: 18px;
        height: 18px;
        border-radius: 4px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    
    #controls {
        text-align: center;
        margin-top: 15px;
        font-size: 14px;
        color: #e0e0e0;
    }
    
    .loading {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 200px;
        font-size: 18px;
    }
</style>
```

</head>
<body>
    <h1>3D Variable Plot by Factor Categories</h1>

```
<div id="container">
    <div id="info">
        <strong>Loading data...</strong><br>
        Trying plot-data.tsv
    </div>
</div>

<div class="legend" id="legend">
    <div class="loading">Loading data...</div>
</div>

<div id="controls">
    Touch and drag to rotate • Pinch to zoom • Tap points for details
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
<script>
    // Global variables
    let data = [];
    let colorMap = {};
    let uniqueFactors = [];
    let scene, camera, renderer, spheres = [];
    let isInteracting = false;
    let mouseX = 0, mouseY = 0;
    let rotationX = 0, rotationY = 0;
    let cameraDistance = 10;
    let lastTouchDistance = 0;
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let selectedObject = null;
    const infoDiv = document.getElementById('info');

    // Load data from TSV file
    async function loadData() {
        const urls = [
            'plot-data.tsv',
            'http://dl.badmath.org/3d/plot-data.tsv'
        ];
        
        for (let i = 0; i < urls.length; i++) {
            try {
                infoDiv.innerHTML = `<strong>Loading data...</strong><br>Trying: ${urls[i]}`;
                
                const response = await fetch(urls[i]);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const tsvText = await response.text();
                
                // Parse TSV using PapaParse
                const parsed = Papa.parse(tsvText, {
                    header: true,
                    delimiter: '\t',
                    dynamicTyping: true,
                    skipEmptyLines: true
                });
                
                if (parsed.errors.length > 0) {
                    throw new Error(`Parse errors: ${parsed.errors[0].message}`);
                }
                
                data = parsed.data.filter(row => row.Variable && row.Factor); // Remove empty rows
                
                if (data.length === 0) {
                    throw new Error('No valid data found in file');
                }
                
                // Extract unique factors and create color mapping
                uniqueFactors = [...new Set(data.map(d => d.Factor))];
                const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f7d794', '#c44569', '#a55eea', '#26de81', '#fd9644'];
                
                colorMap = {};
                uniqueFactors.forEach((factor, index) => {
                    colorMap[factor] = parseInt(colors[index % colors.length].replace('#', '0x'));
                });
                
                // Update legend
                updateLegend();
                
                // Initialize 3D scene
                initScene();
                
                console.log(`Successfully loaded ${data.length} data points with factors:`, uniqueFactors);
                return; // Success - exit the function
                
            } catch (error) {
                console.warn(`Failed to load from ${urls[i]}:`, error.message);
                
                if (i === urls.length - 1) {
                    // Last URL failed
                    infoDiv.innerHTML = `
                        <strong>Error loading data:</strong><br>
                        • plot-data.tsv: Not found<br>
                        • Remote URL: ${error.message}<br><br>
                        Please ensure the TSV file is available.
                    `;
                    document.getElementById('legend').innerHTML = '<div class="loading">Failed to load data</div>';
                }
            }
        }
    }
    
    function updateLegend() {
        const legend = document.getElementById('legend');
        const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f7d794', '#c44569', '#a55eea', '#26de81', '#fd9644'];
        
        legend.innerHTML = uniqueFactors.map((factor, i) => {
            const count = data.filter(d => d.Factor === factor).length;
            return `
                <div class="legend-item">
                    <div class="color-box" style="background: ${colors[i % colors.length]};"></div>
                    <span>${factor} (${count})</span>
                </div>
            `;
        }).join('');
    }

    function createAxes() {
        const axesGroup = new THREE.Group();
        const axisLength = 6;
        
        // X-axis (red)
        const xGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, 0, 0), new THREE.Vector3(axisLength, 0, 0)
        ]);
        const xAxis = new THREE.Line(xGeometry, new THREE.LineBasicMaterial({ color: 0xff4444 }));
        axesGroup.add(xAxis);
        
        // Y-axis (green)
        const yGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, axisLength, 0)
        ]);
        const yAxis = new THREE.Line(yGeometry, new THREE.LineBasicMaterial({ color: 0x44ff44 }));
        axesGroup.add(yAxis);
        
        // Z-axis (blue)
        const zGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, axisLength)
        ]);
        const zAxis = new THREE.Line(zGeometry, new THREE.LineBasicMaterial({ color: 0x4444ff }));
        axesGroup.add(zAxis);
        
        return axesGroup;
    }

    function createDataPoints() {
        const pointsGroup = new THREE.Group();
        spheres = [];

        data.forEach((point) => {
            const geometry = new THREE.SphereGeometry(0.12, 16, 16);
            const material = new THREE.MeshLambertMaterial({ 
                color: colorMap[point.Factor],
                transparent: true,
                opacity: 0.85
            });
            
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.set(point.Dim1, point.Dim2, point.Dim3);
            sphere.userData = { variable: point.Variable, factor: point.Factor };
            
            pointsGroup.add(sphere);
            spheres.push(sphere);
        });

        scene.add(pointsGroup);
    }

    function initScene() {
        // Scene setup
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x2a2a2a);
        
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        
        const container = document.getElementById('container');
        renderer.setSize(container.clientWidth, container.clientHeight);
        
        // Clear any existing canvas
        const existingCanvas = container.querySelector('canvas');
        if (existingCanvas) {
            existingCanvas.remove();
        }
        
        container.appendChild(renderer.domElement);

        // Create axes and data points
        scene.add(createAxes());
        createDataPoints();

        // Set up camera
        camera.position.set(5, 5, 5);
        camera.lookAt(0, 0, 0);

        // Set up controls
        setupControls();

        // Set up lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        // Update info
        infoDiv.innerHTML = `
            <strong>Controls:</strong><br>
            • Touch + drag: Rotate<br>
            • Pinch: Zoom in/out<br>
            • Tap: View details
        `;

        // Start animation
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            const container = document.getElementById('container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });
    }

    function getInputCoords(event) {
        if (event.touches && event.touches.length > 0) {
            return { x: event.touches[0].clientX, y: event.touches[0].clientY };
        }
        return { x: event.clientX, y: event.clientY };
    }

    function getTouchDistance(event) {
        if (event.touches.length === 2) {
            const dx = event.touches[0].clientX - event.touches[1].clientX;
            const dy = event.touches[0].clientY - event.touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }
        return 0;
    }

    function onPointerStart(event) {
        event.preventDefault();
        isInteracting = true;
        const coords = getInputCoords(event);
        mouseX = coords.x;
        mouseY = coords.y;
        
        if (event.touches && event.touches.length === 2) {
            lastTouchDistance = getTouchDistance(event);
        }
    }

    function onPointerMove(event) {
        if (!isInteracting) return;
        event.preventDefault();
        
        if (event.touches && event.touches.length === 2) {
            const touchDistance = getTouchDistance(event);
            if (lastTouchDistance > 0) {
                const scale = touchDistance / lastTouchDistance;
                cameraDistance /= scale;
                cameraDistance = Math.max(3, Math.min(20, cameraDistance));
            }
            lastTouchDistance = touchDistance;
        } else {
            const coords = getInputCoords(event);
            const deltaX = coords.x - mouseX;
            const deltaY = coords.y - mouseY;
            
            rotationY += deltaX * 0.01;
            rotationX += deltaY * 0.01;
            rotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, rotationX));
            
            mouseX = coords.x;
            mouseY = coords.y;
        }
        
        updateCameraPosition();
    }

    function onPointerEnd(event) {
        isInteracting = false;
        lastTouchDistance = 0;
    }

    function updateCameraPosition() {
        const x = cameraDistance * Math.sin(rotationY) * Math.cos(rotationX);
        const y = cameraDistance * Math.sin(rotationX);
        const z = cameraDistance * Math.cos(rotationY) * Math.cos(rotationX);
        
        camera.position.set(x, y, z);
        camera.lookAt(0, 0, 0);
    }

    function setupControls() {
        // Event listeners
        renderer.domElement.addEventListener('mousedown', onPointerStart, { passive: false });
        renderer.domElement.addEventListener('touchstart', onPointerStart, { passive: false });
        renderer.domElement.addEventListener('mousemove', onPointerMove, { passive: false });
        renderer.domElement.addEventListener('touchmove', onPointerMove, { passive: false });
        renderer.domElement.addEventListener('mouseup', onPointerEnd);
        renderer.domElement.addEventListener('touchend', onPointerEnd);
        renderer.domElement.addEventListener('touchcancel', onPointerEnd);

        renderer.domElement.addEventListener('wheel', (event) => {
            event.preventDefault();
            cameraDistance += event.deltaY * 0.01;
            cameraDistance = Math.max(3, Math.min(20, cameraDistance));
            updateCameraPosition();
        }, { passive: false });

        // Interaction detection
        renderer.domElement.addEventListener('click', onTap);
        renderer.domElement.addEventListener('touchend', (event) => {
            if (event.touches.length === 0 && !isInteracting) {
                onTap(event);
            }
        });
    }

    function onTap(event) {
        if (isInteracting || !spheres.length) return;
        
        const rect = renderer.domElement.getBoundingClientRect();
        let clientX, clientY;
        
        if (event.touches && event.touches.length > 0) {
            clientX = event.touches[0].clientX;
            clientY = event.touches[0].clientY;
        } else {
            clientX = event.clientX;
            clientY = event.clientY;
        }
        
        mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
        
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(spheres);
        
        if (intersects.length > 0) {
            const object = intersects[0].object;
            
            // Reset previous selection
            if (selectedObject) {
                selectedObject.scale.set(1, 1, 1);
            }
            
            // Select new object
            selectedObject = object;
            object.scale.set(1.6, 1.6, 1.6);
            
            infoDiv.innerHTML = `
                <strong>${object.userData.variable}</strong><br>
                <strong>Factor:</strong> ${object.userData.factor}<br>
                <strong>Coords:</strong><br>(${object.position.x.toFixed(2)}, ${object.position.y.toFixed(2)}, ${object.position.z.toFixed(2)})<br><br>
                <strong>Controls:</strong><br>
                • Touch + drag: Rotate<br>
                • Pinch: Zoom<br>
                • Tap: Select point
            `;
        } else {
            if (selectedObject) {
                selectedObject.scale.set(1, 1, 1);
                selectedObject = null;
                
                infoDiv.innerHTML = `
                    <strong>Controls:</strong><br>
                    • Touch + drag: Rotate<br>
                    • Pinch: Zoom in/out<br>
                    • Tap: View details
                `;
            }
        }
    }

    // Animation loop
    function animate() {
        if (!scene || !camera || !renderer) return;
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
    }

    // Start loading data when page loads
    window.addEventListener('load', loadData);
</script>
```

</body>
</html>
